\documentclass{IEEEtran}
\usepackage[utf8]{inputenc}
\usepackage{acronym}
\usepackage{footnote}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage[autostyle=true,german=quotes]{csquotes}
\usepackage{todonotes}

\usepackage{hyperref}

\long\def\comment / *#1* /{}


\begin{document}


\title{cowbus -- a small home automation bus}
\author{Robin~Backhaus \and Patrick~Kanzler \and Josef~Schnurrer \and Michael~Zapf}
\date{\today}



\maketitle

\begin{abstract}
    TODO
\end{abstract}


\section{Einleitung}

    \enquote{Smart Home} ist ein Schlagwort, um das man im 21. Jahrhundert
    kaum noch herum kommt. Der moderne Mensch möchte sein Zuhause vernetzen.
    Lichtschalter sind nicht mehr nur noch passive Komponenten in einer
    Elektroinstallation, sie sind aktive Kommunikationspartner in einem großen Netz.
    Das Licht wird nicht nur am Schalter, sondern bequem von der Couch aus mit dem
    Smartphone, automatisch durch Sensoren oder zu einer bestimmten Uhrzeit geschalt. 
    Eingehende E-Mails erscheinen nebenbei im Fernsehbild, die Verdunklung fährt 
    automatisch herunter sobald die Sonne blendet --
    all das ist keine Science Fiction mehr sondern längst Realität.

\section{Motivaton}

    Die meißten erhältlichen \enquote{Smart Home}-Lösungen sind teuer und nicht offen.
    Da die Beliebtheit solcher Systeme immer größer wird, wäre eine größere 
    Zugänglichkeit durch günstige Alternativen und langfristige Sicherheit, 
    sowie mehr Kontrolle für und durch den Anwender wünschenswert.
    Unser Fokus liegt daher auf modernen, offenen Standards und einer drahtlosen, 
    flexiblen und damit einfach zu erweiternden Netzwerktopologie.
    Mit möglichst günstigen Komponenten sollen dabei Sensoren und Aktoren 
    mit verschiedensten Funktionen ermöglicht werden.
    Eine Anknüpfung an vorhandene IP-basierende Netze durch Gateways würde die 
    Anwendungsmöglichkeiten zusätzlich erhöhen 
    und es ermöglichen bereits bestehende und neue externe Anwendungen mit dem 
    cowbus zu verbinden.

\section{Projektidee und -ziele}

    Angefangen hat der cowbus mit der Suche nach einem Projekt für die Vorlesung 
    \enquote{DIY: Personal Fabrication} 2014/2015 von Dr.-Ing. Jürgen Eckert, durch 
    Michael Zapf und Patrick Kanzler. 
    Im Rahmen der Veranstaltung hat sich dann ein Team gebildet, um eine günstige, 
    offene Alternative zu bestehenden Heimbussystemen zu entwickeln. Das Team besteht 
    aus Michael Zapf, Patrick Kanzler, Josef Schnurrer und Robin Backhaus. 
    An zentraler Stelle des Projektes steht die Kommunikation zwischen Netzwerkknoten 
    und ein Netzwerkmodell, dass möglichst flexibel erweiterbar und verkleinerbar 
    sein soll. 
    Dazu wird ein drahtloses Mesh-Netzwerk mit dezentraler Organisation implementiert 
    und an Beispiel-Sensoren und -Aktoren getestet. 
    Als besonderes Merkmal soll das System aus einzelnen, kostengünstigen, sich 
    selbst vermaschenden Knoten bestehen.
    Die Sensoren und Aktoren sollen Ereignisse erzeugen und darauf reagieren können. 
    Optional könnte nach ersten Funktionstests der ausgewählten Hardware oder im 
    Anschluss an die erfolgreiche Implementierung eines Netzwerkes der Standart 
    \enquote{6LoWPAN} implementiert werden. 
    Um keine unbrauchbare Insellösung zu entwickeln, soll neben den Aktoren und 
    Sensoren ein Ethernet-Gateway implementiert werden. Durch dieses soll das 
    Meshnetzwerk als optionales Anwendungsbeispiel eine Verbindung zu 
    einer \enquote{OpenHAB}-Instanz aufnehmen können.

\section{Projektablauf und Meilensteine}

    \section{Konkretisierung der Ziele und Projektplanung}

        TODO: aus Blogbeitrag Brainstorming und Projektbeginn

    \subsection{Kennenlernen von RIOT OS}

        \url{http://www.riot-os.org/} \enquote{The friendly Operating System for the 
        Internet of Things.}, Multithreading, gut portierbar (Schichtenarchitektur), 
        Lizenz: LGPLv2

    \subsection{Funkchip nrf24l01+}

        2,4 GHz (ISM-Band), bis zu 2 Mbps, handliches Modul

    \subsection{Erstes Prototyping mit Discovery Boards}



    \subsection{Erste Funkübertragung und Messung der Funkreichweite}



    \subsection{ARM Cortex M0: STM32F030C8T6}

        bis zu 48 MHz, Gehäuse LQFP48 (7x7 mm)

    \subsection{Platinendesign}

        RGB-LED, Batterie-/Akkubetrieb oder USB, drei Taster, Board ca 4 cm Radius

    \subsection{Zwischenpresentation}
    

\section{Verwendete Programmiersprachen und Techniken}

\section{Verwendete Software und Hilfsmittel}

    GitHub, KiCad, JLink und OpenOCD
\section{Aufgetretene Hindernisse und Risiken}

\section{Systemaufbau}
    TODO

    \subsection{Funkmedium}
        Als Übertragungsmedium kommt eine $2,4GHz$-Technologie
        zum Einsatz. Eine Funktechnologie eignet sich besonders gut dazu
        bereits bestehende Installationen um intelligente Komponenten
        zu erweitern, ohne größere bauliche Änderungen vornehmen zu müssen.

        Die Wahl eines ISM-Frequenzbandes (\enquote{Industrial, Scientific and Medical Band})
        ist in erster Linie bedingt durch die gute Verfügbarkeit von günstigen
        Systemkomponenten und der weltweiten Einsetzbarkeit ohne Anpassung der
        genutzten Frequenzen.

        Genutzt wird der Funkkanal im Moment als Broadcastmedium.
        Jeder Knoten kann also prinzipiell jedes Paket sehen und verarbeiten.
        Dies spart für den Anfang sehr viel Logik und Routingaufwand,
        da Pakete einfach ins Netz geflutet werden können und der entsprechende
        Empfänger (wobei das durchaus mehrere Knoten sein können -- ein Schalter
        könnte beliebig viele Lampen schalten) selbst an der Adresse erkennen
        kann, dass er darauf reagieren muss.

    \subsection{Komponenten}
        Grundsätzlich besteht der cowbus aus drei Typen von Komponenten,
        die auch in Abb. \ref{fig:comp} schematisch dargestellt sind.

        \begin{figure}
            \centering
            \includegraphics[width=0.5\textwidth]{img/system}
            \caption{Schematische Darstellung der beteiligten Komponententypen}
            \label{fig:comp}
        \end{figure}

        \subsubsection{Sensorknoten}
            Sensorknoten sind aus Sicht des Systems im aktuellen Entwurf
            zunächst \enquote{dumm}. Sie enthalten keinerlei Wenn-Dann-Logik
            sondern produzieren ausschließlich Nachrichten mit bestimmten
            Aussagen, z.\,B. \enquote{Ich bin Knoten A und meine erste Taste
            wurde gedrückt}.
        \subsubsection{Aktorknoten}
            Aktorknoten ist die eigentliche Aktion-Reaktion-Logik eingepflanzt.
            Sie lauschen auf dem Kommunikationsmedium und warten auf Anweisungen
            ihre möglichen Aktionen auszuführen.

            Dabei sind zwei Varianten vorgesehen:
            \begin{itemize}
                \item Ein Aktor kann eine Nachricht mit seiner eigenen Adresse
                    erhalten. Das bedeutet für ihn, er soll diese Aktion
                    ausführen, unabhängig davon wer das Ereignis ausgelöst hat.
                \item Ein Aktor kann programmiert werden auf bestimmte andere
                    Adressen und Nachrichten zu reagieren.
                    So kann beispielsweise eingestellt werden, dass ein Aktor
                    dann schaltet, wenn er eine Nachricht entdeckt, in der steht
                    \enquote{Ich bin Knoten A und meine erste Taste
                    wurde gedrückt} (siehe oben).
            \end{itemize}

            Durch diese zwei Varianten ist es auf der einen Seite möglich
            dezentral Nachrichten auszulösen und darauf zu reagieren, wobei
            die Auslöser, also die Sensoren selbst relativ einfach aufgebaut
            sein können. Die aufwändigere Logik, welcher Sensor welche Aktion
            auslöst, kann im Aktor implementiert werden.
            Auf der anderen Seite ist es aber trotzdem möglich, das System
            zentral zu nutzen, indem Sensornachrichten von einem zentralen
            Punkt empfangen werden, der anschließend Nachrichten mit konkreten
            Aktoradressen versendet. So können auch Aktoren \enquote{dumm}
            bleiben und können (z.B. in einem sehr kleinen, temporären Aufbau)
            ohne jede Programmierung verwendet werden, ohne dass sie von den
            konkreten Sensoren wissen müssen.

            Wie ein solches Gateway aussehen könnte zeigt der folgende Abschnitt.

        \subsubsection{Gateway (im Moment der PI)}
            Ein System, dass unabhängig von äußeren Steuerungsinfrastrukturen
            funktionieren kann, ist für die Akzeptanz im Gebäude wichtig.
            Wenn kein Lichtschalter im Haus mehr funktioniert, weil
            im Keller jemand das falsche Netzwerkkabel gezogen hat,
            wird kein Nutzer recht überzeugt sein.
            Umgekehrt ist es allerdings auch wichtig, Schnittstellen zu
            etablierten Kommunikationsstrukturen zu bieten.
            So ist eine Anbindung an vorhandene IPv4- oder IPv6-Netze
            wünschenswert, sodass auch mächtigere Komponenten integriert werden
            können, die unter Umständen noch weitere Kommunikationsmöglichkeiten
            bieten.

            Momentane Lösung dieses Wunsches ist die Integration eines Computers
            in den cowbus. Die offensichtlichste Möglichkeit war auch bei diesem
            Projekt ein Raspberry PI \footnote{\url{http://www.raspberrypi.org/}},
            der bereits alle nötigen Schnittstellen mitbringt, um direkt das
            $2,4-GHz$-Funkmodul und das vorhandene \ac{LAN} anzuschließen.

            Auf dem Raspberry PI läuft ein kleiner in C++ verfasster Daemon.
            Dieser steuert zum einen das Funkmodul und wartet auf Pakete aus
            dem Funknetz.
            Auf der anderen Seite enthält er einen kleinen Websocket-Server,
            über den von jedem beliebigen PC, der ihn über das \ac{LAN}
            erreichen kann, Pakete in das Funknetz verschickt und aus diesem
            empfangen werden kann.

            Dazu steht eine kleine HTML/JavaScript-Anwendung zur Verfügung,
            die in jedem modernen Browser läuffähig sein sollte.


    
    \subsection{Paketaufbau}
            \begin{figure}
            \centering
            \includegraphics[width=0.5\textwidth]{img/paket}
            \caption{Aufbau der Pakete}
            \label{fig:paket}
        \end{figure}

        Hardware bedingt sind wir für die übertragenen Pakete auf 32\,Byte beschränkt, dazu in der späteren Beschreibung über den Funkchip mehr. Abbildung \label{fig:paket} zeigt den Aufbau der Pakete. Die Pakete bestehen aus:
        \begin{itemize}
            \item 5 Bit Sequenznummer: aufsteigent, für jeden Teilnehmer individuell
            \item 8-Bit Time To Live: Maximalwert, der beim Weiterleiten decrementiert wird
            \item 11-Bit Adresse: Kontexabhängig ob Sende / Empfangsadresse
            \item 4-Bit Type 
                \begin{itemize}
                    \item TODO
                \end{itemize}
            \item 1-Bit "is frag": ist das ein aufgeteiltes Paket? - Fragment Header am Anfang vom Payload
            \item 208-Bit Payload - macht 26 Byte
            \item 16-Bit CRC
        \end{itemize}
        
\section{Knoten-Prototyp-Hardware}
Tests mit den Discovery-Boards haben gezeigt, dass das Hardware-Konzept tauglich ist.
Aus diesem Grund wurde ein Protoyp entwickelt.

\subsection{Anforderungen an den Protoypen}
Ziel des cowbus ist die möglichst einfache Integration in bestehende Installationen.
Aus diesem Grund soll die fertige Platine so bemaßt sein, dass sie in einer Unterputzdose montiert werden kann.
Eine Unterputzdose ist rund und bietet etwa 4\,cm Durchmesser.

\todo{günstiger Preis}

\todo{genügend Hardware, um alle Funktionalität zu testen}

\subsection{Umsetzung des Prototypen}

<<<<<<< HEAD
* Wahl des Funkchips (hier 32-Byte Beschränkung, GFSK und Frequenzbänder/Bandbreiten)
=======
\subsubsection{Energieversorgung}
Eine der Anforderungen ist die Möglichkeit das Board in einer Unterputzdose zu montieren.
Damit gibt es zwei Möglichkeiten der Energieversorgung.
Wenn in der Dose Netzspannung verfügbar ist, kann die Energie hieraus bezogen werden.
Andernfalls muss das Board aus einer Batterie versorgt werden.

Für den Prototypen wurde die letztere Option gewählt.
Um ein Netzteil für Unterputzdosenmontage zu realisieren, müsste eine stark integrierte Baugruppe, welche bei Netzspannung arbeitet, entworfen werden.
Dies ist im Rahmen dieses Projektes nicht umsetzbar.
>>>>>>> 816acf5f755d761faed23752bd7595238972035d

Aus diesem Grund wurde eine Energieversorgung per Batterie umgesetzt.
Dazu kommt der Boost-Converter TPS61221 von \emph{Texas Instruments} zum Einsatz.


Batterie, 5V-Versorgung, 5V hat Designfehler

\subsubsection{Prozessor}

\subsubsection{Funkmodul}

\subsubsection{Peripherie}
*Wahl des Prozessors

*Wahl fiel auf STM, weil 8bit zu wenig Dampf hat, ARM hat solide Toolchain

*weiterer Vorteil: Discovery-Boards günstig, um sofort mit der Entwicklung anzufangen




    Platine, Aufbau, Designentscheidungen, ...


\section{Software und System}
    \subsection{Kommunikationsstruktur: Nachrichtenbasiert, jeder Knoten entscheidet anhand Adresse ob er interessiert ist am Inhalt}
    \subsection{RIOT - Was, Warum; evtl. auch kritische Auseinandersetzung?}


\section{Ausblick}

    \subsection{CSMA/CA}
Was geplant ist: CSMA/CA, ...;

    \subsection{Payloadkompression}
    Codierung der Zeichen in der Payload: 
    - in der Payload sollen bei getname und setname und ... für den menschen lesbare Buchstaben als Name eines Knoten übertragen werden
    - Kompression nötig, da sonst nur 208-Bit / 8-Bit (bei Ascii) = 26 Zeichen
    - zur Kompression gibt es hier zwei Möglichkeiten: 
    - Entweder aufgrund der Buchstabenwahrscheinlichkeit einen oder mehrere Buchstaben durch Symbole ersetzen (via Huffman oder Vektor Huffman)
    - hier kommen dann aber unterschiedlich lange Payloads raus und die Anzahl der Buchstaben sollte nicht mit den verwedeten Buchstaben selbst variieren.
    - Oder die Anzahl der Zeichen verringern.
    - Das machen wir hier.
    - es sind dafür als Namen nur Buchstaben, Zahlen und einzelne Sonderzeichen zugelassen
    - 26 Buchstaben, 10 Zahlen, 4 Sonderzeichen (Null-Terminator, Leerzeichen, at-Zeichen, Unterstrich) ergibt 40 Zustände pro Zeichen, die wir als gleich Wahrscheinlich annehmen.
    $log_{2}(40) = 5,32 bit$
    und 
    $log_{2}(40^3) = 5,32 \cdot 3 bit < 16 Bit$
    -> es können 3 Zeichen in 2 Byte codiert werden
    Mit 8-Bit pro Zeichen wären in der Payload 26 Zeichen möglich gewesen, mit Reduzierung der Zustände sind 39 Zeichen möglich.
    Mit 40 Möglichkeiten pro Zeichen ergeben sich bei 3 Zeichen $40^3 = 64000$. Mit 16 Bit können 65536 Zustände abgebildet werden. -> passt.
    - es werden 3 Zeichen ($x_{1}$, $x_{2}$, $x_{3}$) in ein Symbol gepackt. Dieses Symbol kann durch folgendes Polynom berechnet werden:
    $Symbol = x_{1} \cdot 40^{0} + x_{2} \cdot 40^{1} + x_{3} \cdot 40^{2}$
    - Die Decodierung erfolgt über folgende Gleichungen:
    - $x_{1} = Symbol Y 40$
    - $x_{2} = \frac{Symbol - x_{1}}{40} Y 40$
    - $x_{3} = \frac{Symbol - (x_{1} + x_{2} \cdot 40}{40} (Y 40)$

    \subsection{Routing}
        *jeder leitet jedes Paket einmal weiter und merkt sich den Header des Paketes, damit er es kein zweites Mal weiter leitet


kritische Auseinandersetzung mit getätigten Design-Entscheidungen

\section{Zusammenfassung}



\section*{Abkürzungen}
\renewcommand{\IEEEiedlistdecl}{\IEEEsetlabelwidth{CSMA/CA}}
\begin{acronym}
    \acro{CSMA/CA}{Carrier Sense Multiple Access with Collision Avoidance}
    \acro{LAN}{Local Area Network}
\end{acronym}
\renewcommand{\IEEEiedlistdecl}{\relax}% remember to reset \IEEEiedlistdecl


\comment / *
\listoffigures
\clearpage

\listoftables
\clearpage
* /

\nocite*
\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,projektdoku_cowbus}

\end{document}
